{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-bee95e59663e93ea68953431436e51bc97b8e13e",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/DiamondInit.sol": "project/contracts/DiamondInit.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DiamondInit.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./libraries/LibAppStorage.sol\";\nimport \"./libraries/LibDiamond.sol\";\nimport \"./interfaces/IDiamondLoupe.sol\";\nimport \"./interfaces/IDiamondCut.sol\";\nimport \"./interfaces/IERC173.sol\";\n\n/**\n * @title DiamondInit\n * @notice Initializes the Diamond's AppStorage on deployment\n * @dev This contract is called during diamond deployment to set initial values\n *      \n *      WHY SEPARATE INIT CONTRACT?\n *      - Diamond constructor can't access AppStorage directly\n *      - Need to use delegatecall to initialize storage\n *      - This contract provides the initialization function\n *      \n *      CALLED ONCE:\n *      - During diamond deployment\n *      - Never called again\n */\ncontract DiamondInit {\n    \n    /**\n     * @dev Struct for initialization arguments\n     */\n    struct InitArgs {\n        uint256 initialBTLSupply;      // Initial 2BTL supply (e.g., 1 billion)\n        address initialTokenHolder;     // Who receives initial supply\n        uint256 initialTreasuryUSDC;   // Initial USDC in treasury\n        address usdcAddress;            // USDC token address\n        address daiAddress;             // DAI token address\n        address admin;                  // Admin address\n        address oracle;                 // Oracle address (backend)\n        address venueManager;           // Venue manager address\n        address treasuryManager;        // Treasury manager address\n    }\n\n    /**\n     * @notice Initialize all AppStorage values\n     * @param args Initialization arguments\n     */\n    function init(InitArgs memory args) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        // ============ Initialize 2BTL Token ============\n        s.btlName = \"2bottles\";\n        s.btlSymbol = \"2BTL\";\n        s.btlDecimals = 18;\n        s.btlTotalSupply = args.initialBTLSupply;\n        s.btlBalances[args.initialTokenHolder] = args.initialBTLSupply;\n        s.btlTransferFee = 50; // 0.5% = 50 basis points\n        \n        // ============ Initialize PROOF Token ============\n        s.proofName = \"Proof\";\n        s.proofSymbol = \"PROOF\";\n        s.proofDecimals = 6;\n        s.proofTotalSupply = 0; // Starts at zero, minted via staking\n        \n        // ============ Initialize Staking ============\n        s.totalStaked = 0;\n        s.stakingAPY = 1000; // 10% APY = 1000 basis points\n        s.unstakeCooldown = 7 days;\n        s.bondingCurveSlope = 500; // 5% conversion rate initially\n        s.lastBondingCurveUpdate = block.timestamp;\n        \n        // ============ Initialize Rewards ============\n        s.baseCheckInReward = 100 * 1e18; // 100 2BTL\n        s.groupMultiplier = 150; // 1.5x for groups\n        s.maxCheckInsPerDay = 3; // Anti-gaming\n        \n        // ============ Initialize Treasury ============\n        s.treasuryUSDC = args.initialTreasuryUSDC;\n        s.treasuryDAI = 0;\n        s.minCollateralRatio = 12500; // 125%\n        s.targetCollateralRatio = 15000; // 150%\n        s.usdcAddress = args.usdcAddress;\n        s.daiAddress = args.daiAddress;\n        \n        // ============ Initialize Governance ============\n        s.proposalCount = 0;\n        s.votingDelay = 7200; // ~1 day (assuming 12 sec blocks)\n        s.votingPeriod = 21600; // ~3 days\n        s.proposalThreshold = 1000 * 1e18; // Need 1000 2BTL to propose\n        s.quorumVotes = 100000 * 1e18; // Need 100k 2BTL votes for quorum\n        \n        // ============ Initialize Access Control ============\n        s.roles[LibAppStorage.ADMIN_ROLE][args.admin] = true;\n        s.roles[LibAppStorage.ORACLE_ROLE][args.oracle] = true;\n        s.roles[LibAppStorage.VENUE_MANAGER_ROLE][args.venueManager] = true;\n        s.roles[LibAppStorage.TREASURY_MANAGER_ROLE][args.treasuryManager] = true;\n        \n        // ============ Initialize Emergency State ============\n        s.paused = false;\n        s.stakingPaused = false;\n        s.rewardsPaused = false;\n        \n        // ============ Initialize Stats ============\n        s.totalCheckIns = 0;\n        s.totalRewardsDistributed = 0;\n        s.totalProofMinted = 0;\n        s.totalProofRedeemed = 0;\n        \n        // ============ Set up ERC-165 interfaces ============\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    }\n}\n"
      },
      "project/contracts/interfaces/IDiamondCut.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDiamondCut {\n    enum FacetCutAction { Add, Replace, Remove }\n\n    // Add = 0, Replace = 1, Remove = 2\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _cut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    function diamondCut(FacetCut[] calldata _cut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _cut, address _init, bytes _calldata);\n}\n"
      },
      "project/contracts/interfaces/IDiamondLoupe.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDiamondLoupe {\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// These functions are expected to be called frequently by tools.\n    function facets() external view returns (Facet[] memory);\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);\n    function facetAddresses() external view returns (address[] memory);\n    function facetAddress(bytes4 _functionSelector) external view returns (address);\n}\n"
      },
      "project/contracts/interfaces/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function owner() external view returns (address owner_);\n    function transferOwnership(address _newOwner) external;\n}\n"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibAppStorage\n * @notice Defines the shared storage structure for all 2bottles facets\n * @dev Uses the \"AppStorage\" pattern where all app data lives in one struct\n *      This struct is stored at a specific storage slot to avoid collisions\n *      \n *      WHY THIS PATTERN?\n *      - All facets can access the same data\n *      - No storage collisions between facets\n *      - Easy to see all state in one place\n *      - More gas efficient than multiple storage reads\n */\nlibrary LibAppStorage {\n    // ============ Storage Position ============\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"2bottles.app.storage\");\n\n    // ============ Constants ============\n    uint256 constant BASIS_POINTS = 10000; // For percentage calculations (100% = 10000)\n    uint256 constant SECONDS_PER_DAY = 86400;\n    uint256 constant BLOCKS_PER_DAY = 7200; // Assuming ~12 sec blocks\n\n    // ============ Role Constants ============\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 constant VENUE_MANAGER_ROLE = keccak256(\"VENUE_MANAGER_ROLE\");\n    bytes32 constant TREASURY_MANAGER_ROLE = keccak256(\"TREASURY_MANAGER_ROLE\");\n\n    // ============ Structs ============\n\n    /**\n     * @dev Information about a user's stake\n     */\n    struct StakeInfo {\n        uint256 amount;\n        uint256 stakedAt;\n        uint256 proofMinted;\n        uint256 lastRewardUpdate;\n    }\n\n    /**\n     * @dev Information about a user's rewards\n     */\n    struct RewardInfo {\n        uint256 totalEarned;\n        uint256 lastCheckIn;\n        uint256 checkInCount;\n        uint256 referralCount;\n    }\n\n    /**\n     * @dev Information about a venue\n     */\n    struct VenueInfo {\n        bool isActive;\n        uint256 multiplier;\n        uint256 totalCheckIns;\n        uint256 rewardsDistributed;\n    }\n\n    /**\n     * @dev Information about a governance proposal\n     */\n    struct Proposal {\n        address proposer;\n        string description;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 startBlock;\n        uint256 endBlock;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev Tracks voting on a proposal\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint256 votes;\n    }\n\n    /**\n     * @dev Checkpoint for vote delegation\n     */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /**\n     * @dev The main application storage struct\n     */\n    struct AppStorage {\n        // ============ 2BTL Token State ============\n        string btlName;\n        string btlSymbol;\n        uint8 btlDecimals;\n        uint256 btlTotalSupply;\n        mapping(address => uint256) btlBalances;\n        mapping(address => mapping(address => uint256)) btlAllowances;\n        uint256 btlTransferFee; // Basis points (50 = 0.5%)\n\n        // ============ PROOF Token State ============\n        string proofName;\n        string proofSymbol;\n        uint8 proofDecimals;\n        uint256 proofTotalSupply;\n        mapping(address => uint256) proofBalances;\n        mapping(address => mapping(address => uint256)) proofAllowances;\n\n        // ============ Staking State ============\n        mapping(address => StakeInfo) stakes;\n        uint256 totalStaked;\n        uint256 stakingAPY; // Basis points (1000 = 10%)\n        uint256 unstakeCooldown;\n        mapping(address => uint256) unstakeRequestTime;\n\n        // ============ Rewards State ============\n        mapping(address => RewardInfo) rewardInfo;\n        mapping(bytes32 => bool) usedCheckInHashes;\n        uint256 baseCheckInReward;\n        uint256 groupMultiplier;\n        uint256 maxCheckInsPerDay;\n        mapping(address => VenueInfo) venues;\n        address[] venueList;\n\n        // ============ Treasury State ============\n        uint256 treasuryUSDC;\n        uint256 treasuryDAI;\n        uint256 minCollateralRatio;\n        uint256 targetCollateralRatio;\n        address usdcAddress;\n        address daiAddress;\n\n        // ============ Governance State ============\n        mapping(uint256 => Proposal) proposals;\n        uint256 proposalCount;\n        mapping(uint256 => mapping(address => Receipt)) receipts;\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumVotes;\n        mapping(address => address) delegates;\n        mapping(address => uint256) numCheckpoints;\n        mapping(address => mapping(uint256 => Checkpoint)) checkpoints;\n\n        // ============ Access Control ============\n        mapping(bytes32 => mapping(address => bool)) roles;\n\n        // ============ Emergency State ============\n        bool paused;\n        bool stakingPaused;\n        bool rewardsPaused;\n\n        // ============ Bonding Curve State ============\n        uint256 bondingCurveSlope;\n        uint256 lastBondingCurveUpdate;\n\n        // ============ Anti-Gaming ============\n        mapping(address => mapping(uint256 => uint256)) dailyCheckIns;\n        mapping(address => uint256) lastCheckInBlock;\n\n        // ============ Stats & Analytics ============\n        uint256 totalCheckIns;\n        uint256 totalRewardsDistributed;\n        uint256 totalProofMinted;\n        uint256 totalProofRedeemed;\n    }\n\n    // ============ Storage Access ============\n\n    /**\n     * @notice Get the app storage struct\n     */\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ============ Role Modifiers ============\n\n    function enforceIsAdmin() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ADMIN_ROLE][msg.sender], \"LibAppStorage: Must be admin\");\n    }\n\n    function enforceIsOracle() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ORACLE_ROLE][msg.sender], \"LibAppStorage: Must be oracle\");\n    }\n\n    function enforceNotPaused() internal view {\n        require(!appStorage().paused, \"LibAppStorage: Contract is paused\");\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return appStorage().roles[role][account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = true;\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = false;\n    }\n}\n"
      },
      "project/contracts/libraries/LibDiamond.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IDiamondLoupe.sol\";\n\n/**\n * @title LibDiamond\n * @notice Core library for the Diamond Pattern (EIP-2535)\n * @dev This library manages:\n *      - Facet addresses and function selectors\n *      - DiamondCut operations (add/replace/remove facets)\n *      - Contract ownership\n */\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // selector => facetAddress and selector position in facetFunctionSelectors\n        mapping(bytes4 => FacetAddressAndSelectorPosition) selectorToFacetAndPosition;\n        // facetAddress => function selectors\n        mapping(address => bytes4[]) facetFunctionSelectors;\n        // list of facet addresses\n        address[] facetAddresses;\n        // owner\n        address contractOwner;\n        // supported interfaces (ERC-165)\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    // ============ Events ============\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // ============ Custom Errors ============\n    error NotContractOwner(address user, address owner);\n    error NoSelectorsProvided();\n    error CannotAddSelectorsToZeroAddress();\n    error FunctionAlreadyExists(bytes4 selector);\n    error CannotReplaceFunctionsFromZeroAddress();\n    error CannotReplaceWithSameFunction(bytes4 selector);\n    error FunctionDoesNotExist(bytes4 selector);\n    error RemoveFacetAddressMustBeZero();\n    error InitializationFailed(address init, bytes data);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address) {\n        return diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n        }\n    }\n\n    /**\n     * @notice Main function to perform diamond cuts\n     */\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[i].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[i].facetAddress, _diamondCut[i].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[i].facetAddress, _diamondCut[i].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(address(0), _diamondCut[i].functionSelectors);\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress == address(0)) revert CannotAddSelectorsToZeroAddress();\n        \n        DiamondStorage storage ds = diamondStorage();\n        enforceHasContractCode(_facetAddress);\n\n        // if this is a new facet, add to facetAddresses\n        if (ds.facetFunctionSelectors[_facetAddress].length == 0) {\n            ds.facetAddresses.push(_facetAddress);\n        }\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            if (ds.selectorToFacetAndPosition[selector].facetAddress != address(0)) {\n                revert FunctionAlreadyExists(selector);\n            }\n            ds.facetFunctionSelectors[_facetAddress].push(selector);\n            ds.selectorToFacetAndPosition[selector] = FacetAddressAndSelectorPosition({\n                facetAddress: _facetAddress,\n                selectorPosition: uint16(ds.facetFunctionSelectors[_facetAddress].length - 1)\n            });\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress == address(0)) revert CannotReplaceFunctionsFromZeroAddress();\n        \n        DiamondStorage storage ds = diamondStorage();\n        enforceHasContractCode(_facetAddress);\n\n        if (ds.facetFunctionSelectors[_facetAddress].length == 0) {\n            ds.facetAddresses.push(_facetAddress);\n        }\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\n            if (oldFacet == _facetAddress) revert CannotReplaceWithSameFunction(selector);\n            if (oldFacet == address(0)) revert FunctionDoesNotExist(selector);\n\n            // remove selector from old facet\n            bytes4[] storage oldSelectors = ds.facetFunctionSelectors[oldFacet];\n            uint16 selectorPos = ds.selectorToFacetAndPosition[selector].selectorPosition;\n            uint256 lastPos = oldSelectors.length - 1;\n            if (selectorPos != lastPos) {\n                bytes4 lastSelector = oldSelectors[lastPos];\n                oldSelectors[selectorPos] = lastSelector;\n                ds.selectorToFacetAndPosition[lastSelector].selectorPosition = selectorPos;\n            }\n            oldSelectors.pop();\n\n            // add selector to new facet\n            ds.facetFunctionSelectors[_facetAddress].push(selector);\n            ds.selectorToFacetAndPosition[selector] = FacetAddressAndSelectorPosition({\n                facetAddress: _facetAddress,\n                selectorPosition: uint16(ds.facetFunctionSelectors[_facetAddress].length - 1)\n            });\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress != address(0)) revert RemoveFacetAddressMustBeZero();\n        \n        DiamondStorage storage ds = diamondStorage();\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            FacetAddressAndSelectorPosition memory old = ds.selectorToFacetAndPosition[selector];\n            address oldFacet = old.facetAddress;\n            if (oldFacet == address(0)) revert FunctionDoesNotExist(selector);\n\n            // remove selector from old facet\n            bytes4[] storage oldSelectors = ds.facetFunctionSelectors[oldFacet];\n            uint256 lastPos = oldSelectors.length - 1;\n            uint16 selectorPos = old.selectorPosition;\n            if (selectorPos != lastPos) {\n                bytes4 lastSelector = oldSelectors[lastPos];\n                oldSelectors[selectorPos] = lastSelector;\n                ds.selectorToFacetAndPosition[lastSelector].selectorPosition = selectorPos;\n            }\n            oldSelectors.pop();\n            delete ds.selectorToFacetAndPosition[selector];\n\n            // if no selectors left for facet, remove facetAddress\n            if (oldSelectors.length == 0) {\n                uint256 len = ds.facetAddresses.length;\n                for (uint256 j = 0; j < len; j++) {\n                    if (ds.facetAddresses[j] == oldFacet) {\n                        uint256 last = ds.facetAddresses.length - 1;\n                        if (j != last) {\n                            ds.facetAddresses[j] = ds.facetAddresses[last];\n                        }\n                        ds.facetAddresses.pop();\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamond: _calldata must be empty if _init is zero\");\n            return;\n        }\n        enforceHasContractCode(_init);\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let size := mload(error)\n                    revert(add(32, error), size)\n                }\n            }\n            revert InitializationFailed(_init, _calldata);\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, \"LibDiamond: Address has no code\");\n    }\n\n    function setSupportedInterface(bytes4 _interfaceId, bool _supported) internal {\n        diamondStorage().supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\n        return diamondStorage().supportedInterfaces[_interfaceId];\n    }\n}"
      }
    }
  }
}