{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-b01f7962a33bfda9031b29a6042ff966588b9723",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/facets/TreasuryFacet.sol": "project/contracts/facets/TreasuryFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/TreasuryFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../libraries/LibAppStorage.sol\";\n\n/**\n * @title TreasuryFacet\n * @notice Manages the protocol treasury and collateralization\n * @dev The treasury is the heart of the PROOF stability mechanism\n *      \n *      TREASURY HOLDINGS:\n *      - USDC (primary stablecoin)\n *      - DAI (diversification)\n *      - Protocol fees from transactions\n *      \n *      CRITICAL FUNCTIONS:\n *      1. Maintain collateralization ratio (min 125%, target 150%)\n *      2. Allow PROOF redemption for USDC\n *      3. Accept deposits from various sources\n *      4. Buyback 2BTL with excess reserves\n */\ncontract TreasuryFacet {\n    \n    // ============ Events ============\n    event TreasuryDeposit(address indexed token, uint256 amount, address indexed from);\n    event TreasuryWithdrawal(address indexed token, uint256 amount, address indexed to);\n    event CollateralRatioUpdated(uint256 newMinRatio, uint256 newTargetRatio);\n    event BuybackExecuted(uint256 usdcSpent, uint256 btlBought);\n    event EmergencyWithdraw(address indexed token, uint256 amount, address indexed to);\n\n    // ============ Deposit Functions ============\n\n    /**\n     * @notice Deposit USDC into treasury\n     */\n    function depositUSDC(uint256 amount) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(amount > 0, \"Treasury: Cannot deposit zero\");\n        \n        // Note: In production, transfer USDC from msg.sender\n        // IERC20(s.usdcAddress).transferFrom(msg.sender, address(this), amount)\n        \n        s.treasuryUSDC += amount;\n        \n        emit TreasuryDeposit(s.usdcAddress, amount, msg.sender);\n    }\n\n    /**\n     * @notice Deposit DAI into treasury\n     */\n    function depositDAI(uint256 amount) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(amount > 0, \"Treasury: Cannot deposit zero\");\n        \n        s.treasuryDAI += amount;\n        \n        emit TreasuryDeposit(s.daiAddress, amount, msg.sender);\n    }\n\n    // ============ Withdrawal Functions ============\n\n    /**\n     * @notice Withdraw USDC from treasury (maintains collateral ratio)\n     */\n    function withdrawUSDC(uint256 amount, address to) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(s.roles[LibAppStorage.TREASURY_MANAGER_ROLE][msg.sender], \"Treasury: Not authorized\");\n        LibAppStorage.enforceNotPaused();\n        require(amount > 0, \"Treasury: Cannot withdraw zero\");\n        require(to != address(0), \"Treasury: Invalid recipient\");\n        require(s.treasuryUSDC >= amount, \"Treasury: Insufficient USDC\");\n        \n        // Check collateralization after withdrawal\n        uint256 newUSDC = s.treasuryUSDC - amount;\n        uint256 totalCollateral = newUSDC + s.treasuryDAI;\n        uint256 requiredCollateral = (s.proofTotalSupply * s.minCollateralRatio) / LibAppStorage.BASIS_POINTS;\n        \n        require(totalCollateral >= requiredCollateral, \"Treasury: Would break collateral ratio\");\n        \n        s.treasuryUSDC = newUSDC;\n        \n        emit TreasuryWithdrawal(s.usdcAddress, amount, to);\n    }\n\n    /**\n     * @notice Withdraw DAI from treasury (maintains collateral ratio)\n     */\n    function withdrawDAI(uint256 amount, address to) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(s.roles[LibAppStorage.TREASURY_MANAGER_ROLE][msg.sender], \"Treasury: Not authorized\");\n        LibAppStorage.enforceNotPaused();\n        require(amount > 0, \"Treasury: Cannot withdraw zero\");\n        require(to != address(0), \"Treasury: Invalid recipient\");\n        require(s.treasuryDAI >= amount, \"Treasury: Insufficient DAI\");\n        \n        // Check collateralization after withdrawal\n        uint256 newDAI = s.treasuryDAI - amount;\n        uint256 totalCollateral = s.treasuryUSDC + newDAI;\n        uint256 requiredCollateral = (s.proofTotalSupply * s.minCollateralRatio) / LibAppStorage.BASIS_POINTS;\n        \n        require(totalCollateral >= requiredCollateral, \"Treasury: Would break collateral ratio\");\n        \n        s.treasuryDAI = newDAI;\n        \n        emit TreasuryWithdrawal(s.daiAddress, amount, to);\n    }\n\n    // ============ Buyback Functions ============\n\n    /**\n     * @notice Execute 2BTL buyback with excess reserves\n     */\n    function executeBuyback(uint256 usdcAmount) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(s.roles[LibAppStorage.TREASURY_MANAGER_ROLE][msg.sender], \"Treasury: Not authorized\");\n        LibAppStorage.enforceNotPaused();\n        require(usdcAmount > 0, \"Treasury: Cannot buyback zero\");\n        \n        // Check we're overcollateralized\n        uint256 currentRatio = _getCollateralizationRatio();\n        require(currentRatio > s.targetCollateralRatio, \"Treasury: Not overcollateralized\");\n        \n        // Calculate how much we can safely spend\n        uint256 totalCollateral = s.treasuryUSDC + s.treasuryDAI;\n        uint256 targetCollateral = (s.proofTotalSupply * s.targetCollateralRatio) / LibAppStorage.BASIS_POINTS;\n        uint256 excessCollateral = totalCollateral > targetCollateral ? totalCollateral - targetCollateral : 0;\n        \n        require(usdcAmount <= excessCollateral, \"Treasury: Amount exceeds excess collateral\");\n        require(usdcAmount <= s.treasuryUSDC, \"Treasury: Insufficient USDC\");\n        \n        s.treasuryUSDC -= usdcAmount;\n        \n        // Simulate buying 2BTL (in production: use DEX)\n        // Assume price of 1 2BTL = $0.05\n        uint256 btlBought = (usdcAmount * 1e18) / (5 * 1e16);\n        \n        // Burn the bought 2BTL (deflationary)\n        if (btlBought > 0 && s.btlTotalSupply >= btlBought) {\n            s.btlTotalSupply -= btlBought;\n        }\n        \n        emit BuybackExecuted(usdcAmount, btlBought);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get treasury balances\n     */\n    function getTreasuryBalances() external view returns (\n        uint256 usdcBalance,\n        uint256 daiBalance,\n        uint256 totalValue\n    ) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        usdcBalance = s.treasuryUSDC;\n        daiBalance = s.treasuryDAI;\n        totalValue = usdcBalance + daiBalance;\n    }\n\n    /**\n     * @notice Get current collateralization ratio\n     */\n    function getCollateralizationRatio() external view returns (uint256) {\n        return _getCollateralizationRatio();\n    }\n\n    /**\n     * @notice Get collateralization health status\n     */\n    function getCollateralizationHealth() external view returns (\n        bool isHealthy,\n        uint256 currentRatio,\n        uint256 minRatio,\n        uint256 targetRatio\n    ) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        currentRatio = _getCollateralizationRatio();\n        minRatio = s.minCollateralRatio;\n        targetRatio = s.targetCollateralRatio;\n        isHealthy = currentRatio >= minRatio;\n    }\n\n    /**\n     * @notice Calculate excess collateral available for buyback\n     */\n    function getExcessCollateral() external view returns (uint256 excessUSDC) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        uint256 currentRatio = _getCollateralizationRatio();\n        if (currentRatio <= s.targetCollateralRatio) {\n            return 0;\n        }\n        \n        uint256 totalCollateral = s.treasuryUSDC + s.treasuryDAI;\n        uint256 targetCollateral = (s.proofTotalSupply * s.targetCollateralRatio) / LibAppStorage.BASIS_POINTS;\n        \n        return totalCollateral > targetCollateral ? totalCollateral - targetCollateral : 0;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Set collateralization ratios\n     */\n    function setCollateralRatios(uint256 newMinRatio, uint256 newTargetRatio) external {\n        LibAppStorage.enforceIsAdmin();\n        require(newMinRatio >= 10000, \"Treasury: Min ratio must be >= 100%\");\n        require(newTargetRatio >= newMinRatio, \"Treasury: Target must be >= min\");\n        require(newTargetRatio <= 30000, \"Treasury: Target ratio too high\");\n        \n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        s.minCollateralRatio = newMinRatio;\n        s.targetCollateralRatio = newTargetRatio;\n        \n        emit CollateralRatioUpdated(newMinRatio, newTargetRatio);\n    }\n\n    /**\n     * @notice Set stablecoin addresses\n     */\n    function setStablecoinAddresses(address usdcAddress, address daiAddress) external {\n        LibAppStorage.enforceIsAdmin();\n        require(usdcAddress != address(0), \"Treasury: Invalid USDC address\");\n        require(daiAddress != address(0), \"Treasury: Invalid DAI address\");\n        \n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        s.usdcAddress = usdcAddress;\n        s.daiAddress = daiAddress;\n    }\n\n    /**\n     * @notice Emergency withdraw (bypasses collateral checks - use with caution!)\n     */\n    function emergencyWithdraw(address token, uint256 amount, address to) external {\n        LibAppStorage.enforceIsAdmin();\n        require(to != address(0), \"Treasury: Invalid recipient\");\n        \n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        if (token == s.usdcAddress) {\n            require(s.treasuryUSDC >= amount, \"Treasury: Insufficient USDC\");\n            s.treasuryUSDC -= amount;\n        } else if (token == s.daiAddress) {\n            require(s.treasuryDAI >= amount, \"Treasury: Insufficient DAI\");\n            s.treasuryDAI -= amount;\n        } else {\n            revert(\"Treasury: Unsupported token\");\n        }\n        \n        emit EmergencyWithdraw(token, amount, to);\n    }\n\n    /**\n     * @notice Set global pause state\n     */\n    function setPaused(bool paused) external {\n        LibAppStorage.enforceIsAdmin();\n        LibAppStorage.appStorage().paused = paused;\n    }\n\n    // ============ Role Management ============\n\n    /**\n     * @notice Grant a role to an address\n     */\n    function grantRole(bytes32 role, address account) external {\n        LibAppStorage.enforceIsAdmin();\n        LibAppStorage.grantRole(role, account);\n    }\n\n    /**\n     * @notice Revoke a role from an address\n     */\n    function revokeRole(bytes32 role, address account) external {\n        LibAppStorage.enforceIsAdmin();\n        LibAppStorage.revokeRole(role, account);\n    }\n\n    /**\n     * @notice Check if an address has a role\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool) {\n        return LibAppStorage.hasRole(role, account);\n    }\n\n    // ============ Internal Functions ============\n\n    function _getCollateralizationRatio() internal view returns (uint256) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        if (s.proofTotalSupply == 0) {\n            return type(uint256).max;\n        }\n        \n        uint256 totalCollateral = s.treasuryUSDC + s.treasuryDAI;\n        return (totalCollateral * LibAppStorage.BASIS_POINTS) / s.proofTotalSupply;\n    }\n}\n"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibAppStorage\n * @notice Defines the shared storage structure for all 2bottles facets\n * @dev Uses the \"AppStorage\" pattern where all app data lives in one struct\n *      This struct is stored at a specific storage slot to avoid collisions\n *      \n *      WHY THIS PATTERN?\n *      - All facets can access the same data\n *      - No storage collisions between facets\n *      - Easy to see all state in one place\n *      - More gas efficient than multiple storage reads\n */\nlibrary LibAppStorage {\n    // ============ Storage Position ============\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"2bottles.app.storage\");\n\n    // ============ Constants ============\n    uint256 constant BASIS_POINTS = 10000; // For percentage calculations (100% = 10000)\n    uint256 constant SECONDS_PER_DAY = 86400;\n    uint256 constant BLOCKS_PER_DAY = 7200; // Assuming ~12 sec blocks\n\n    // ============ Role Constants ============\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 constant VENUE_MANAGER_ROLE = keccak256(\"VENUE_MANAGER_ROLE\");\n    bytes32 constant TREASURY_MANAGER_ROLE = keccak256(\"TREASURY_MANAGER_ROLE\");\n\n    // ============ Structs ============\n\n    /**\n     * @dev Information about a user's stake\n     */\n    struct StakeInfo {\n        uint256 amount;\n        uint256 stakedAt;\n        uint256 proofMinted;\n        uint256 lastRewardUpdate;\n    }\n\n    /**\n     * @dev Information about a user's rewards\n     */\n    struct RewardInfo {\n        uint256 totalEarned;\n        uint256 lastCheckIn;\n        uint256 checkInCount;\n        uint256 referralCount;\n    }\n\n    /**\n     * @dev Information about a venue\n     */\n    struct VenueInfo {\n        bool isActive;\n        uint256 multiplier;\n        uint256 totalCheckIns;\n        uint256 rewardsDistributed;\n    }\n\n    /**\n     * @dev Information about a governance proposal\n     */\n    struct Proposal {\n        address proposer;\n        string description;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 startBlock;\n        uint256 endBlock;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev Tracks voting on a proposal\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint256 votes;\n    }\n\n    /**\n     * @dev Checkpoint for vote delegation\n     */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /**\n     * @dev The main application storage struct\n     */\n    struct AppStorage {\n        // ============ 2BTL Token State ============\n        string btlName;\n        string btlSymbol;\n        uint8 btlDecimals;\n        uint256 btlTotalSupply;\n        mapping(address => uint256) btlBalances;\n        mapping(address => mapping(address => uint256)) btlAllowances;\n        uint256 btlTransferFee; // Basis points (50 = 0.5%)\n\n        // ============ PROOF Token State ============\n        string proofName;\n        string proofSymbol;\n        uint8 proofDecimals;\n        uint256 proofTotalSupply;\n        mapping(address => uint256) proofBalances;\n        mapping(address => mapping(address => uint256)) proofAllowances;\n\n        // ============ Staking State ============\n        mapping(address => StakeInfo) stakes;\n        uint256 totalStaked;\n        uint256 stakingAPY; // Basis points (1000 = 10%)\n        uint256 unstakeCooldown;\n        mapping(address => uint256) unstakeRequestTime;\n\n        // ============ Rewards State ============\n        mapping(address => RewardInfo) rewardInfo;\n        mapping(bytes32 => bool) usedCheckInHashes;\n        uint256 baseCheckInReward;\n        uint256 groupMultiplier;\n        uint256 maxCheckInsPerDay;\n        mapping(address => VenueInfo) venues;\n        address[] venueList;\n\n        // ============ Treasury State ============\n        uint256 treasuryUSDC;\n        uint256 treasuryDAI;\n        uint256 minCollateralRatio;\n        uint256 targetCollateralRatio;\n        address usdcAddress;\n        address daiAddress;\n\n        // ============ Governance State ============\n        mapping(uint256 => Proposal) proposals;\n        uint256 proposalCount;\n        mapping(uint256 => mapping(address => Receipt)) receipts;\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumVotes;\n        mapping(address => address) delegates;\n        mapping(address => uint256) numCheckpoints;\n        mapping(address => mapping(uint256 => Checkpoint)) checkpoints;\n\n        // ============ Access Control ============\n        mapping(bytes32 => mapping(address => bool)) roles;\n\n        // ============ Emergency State ============\n        bool paused;\n        bool stakingPaused;\n        bool rewardsPaused;\n\n        // ============ Bonding Curve State ============\n        uint256 bondingCurveSlope;\n        uint256 lastBondingCurveUpdate;\n\n        // ============ Anti-Gaming ============\n        mapping(address => mapping(uint256 => uint256)) dailyCheckIns;\n        mapping(address => uint256) lastCheckInBlock;\n\n        // ============ Stats & Analytics ============\n        uint256 totalCheckIns;\n        uint256 totalRewardsDistributed;\n        uint256 totalProofMinted;\n        uint256 totalProofRedeemed;\n    }\n\n    // ============ Storage Access ============\n\n    /**\n     * @notice Get the app storage struct\n     */\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ============ Role Modifiers ============\n\n    function enforceIsAdmin() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ADMIN_ROLE][msg.sender], \"LibAppStorage: Must be admin\");\n    }\n\n    function enforceIsOracle() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ORACLE_ROLE][msg.sender], \"LibAppStorage: Must be oracle\");\n    }\n\n    function enforceNotPaused() internal view {\n        require(!appStorage().paused, \"LibAppStorage: Contract is paused\");\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return appStorage().roles[role][account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = true;\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = false;\n    }\n}\n"
      }
    }
  }
}