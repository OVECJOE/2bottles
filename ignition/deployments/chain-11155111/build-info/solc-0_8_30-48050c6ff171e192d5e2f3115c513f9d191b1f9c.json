{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-48050c6ff171e192d5e2f3115c513f9d191b1f9c",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/facets/StakingFacet.sol": "project/contracts/facets/StakingFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/StakingFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../libraries/LibAppStorage.sol\";\n\n/**\n * @title StakingFacet\n * @notice Stake 2BTL to mint PROOF tokens via bonding curve\n * @dev This is the bridge between volatile 2BTL and stable PROOF\n *      \n *      HOW IT WORKS:\n *      1. User stakes 2BTL (locked for 7 days default)\n *      2. System mints PROOF based on bonding curve\n *      3. After cooldown, user can unstake and get 2BTL back\n *      4. PROOF remains in circulation (unless burned)\n *      \n *      SECURITY:\n *      - Cooldown prevents flash loan attacks\n *      - Collateralization ratio enforced\n *      - Pausable in emergency\n */\ncontract StakingFacet {\n    \n    // ============ Events ============\n    event Staked(address indexed user, uint256 btlAmount, uint256 proofMinted);\n    event UnstakeRequested(address indexed user, uint256 amount, uint256 unlockTime);\n    event Unstaked(address indexed user, uint256 btlAmount);\n    event BondingCurveUpdated(uint256 newSlope);\n\n    // ============ Staking Functions ============\n\n    /**\n     * @notice Stake 2BTL to mint PROOF\n     * @param btlAmount Amount of 2BTL to stake\n     * @return proofMinted Amount of PROOF minted\n     */\n    function stake(uint256 btlAmount) external returns (uint256 proofMinted) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(!s.stakingPaused, \"Staking: Staking is paused\");\n        require(btlAmount > 0, \"Staking: Cannot stake zero\");\n        require(s.btlBalances[msg.sender] >= btlAmount, \"Staking: Insufficient 2BTL balance\");\n        \n        // Calculate PROOF to mint using bonding curve\n        proofMinted = calculateProofMint(btlAmount);\n        require(proofMinted > 0, \"Staking: PROOF amount too small\");\n        \n        // Transfer 2BTL from user to contract (staking pool)\n        unchecked {\n            s.btlBalances[msg.sender] -= btlAmount;\n        }\n        s.btlBalances[address(this)] += btlAmount;\n        \n        // Update stake info\n        LibAppStorage.StakeInfo storage stakeInfo = s.stakes[msg.sender];\n        stakeInfo.amount += btlAmount;\n        stakeInfo.stakedAt = block.timestamp;\n        stakeInfo.proofMinted += proofMinted;\n        stakeInfo.lastRewardUpdate = block.timestamp;\n        \n        s.totalStaked += btlAmount;\n        \n        // Mint PROOF to user\n        s.proofBalances[msg.sender] += proofMinted;\n        s.proofTotalSupply += proofMinted;\n        s.totalProofMinted += proofMinted;\n        \n        emit Staked(msg.sender, btlAmount, proofMinted);\n    }\n\n    /**\n     * @notice Request to unstake 2BTL (starts cooldown)\n     * @param btlAmount Amount of 2BTL to unstake\n     */\n    function requestUnstake(uint256 btlAmount) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(btlAmount > 0, \"Staking: Cannot unstake zero\");\n        \n        LibAppStorage.StakeInfo storage stakeInfo = s.stakes[msg.sender];\n        require(stakeInfo.amount >= btlAmount, \"Staking: Insufficient staked amount\");\n        \n        // Set unstake request time\n        s.unstakeRequestTime[msg.sender] = block.timestamp;\n        \n        uint256 unlockTime = block.timestamp + s.unstakeCooldown;\n        emit UnstakeRequested(msg.sender, btlAmount, unlockTime);\n    }\n\n    /**\n     * @notice Execute unstake after cooldown period\n     * @param btlAmount Amount of 2BTL to unstake\n     */\n    function executeUnstake(uint256 btlAmount) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(btlAmount > 0, \"Staking: Cannot unstake zero\");\n        \n        // Check cooldown\n        uint256 requestTime = s.unstakeRequestTime[msg.sender];\n        require(requestTime > 0, \"Staking: No unstake request found\");\n        require(block.timestamp >= requestTime + s.unstakeCooldown, \"Staking: Cooldown not passed\");\n        \n        LibAppStorage.StakeInfo storage stakeInfo = s.stakes[msg.sender];\n        require(stakeInfo.amount >= btlAmount, \"Staking: Insufficient staked amount\");\n        \n        // Update stake info\n        unchecked {\n            stakeInfo.amount -= btlAmount;\n            s.totalStaked -= btlAmount;\n            s.btlBalances[address(this)] -= btlAmount;\n        }\n        s.btlBalances[msg.sender] += btlAmount;\n        \n        // Clear unstake request\n        s.unstakeRequestTime[msg.sender] = 0;\n        \n        emit Unstaked(msg.sender, btlAmount);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get staking info for a user\n     */\n    function getStakeInfo(address user) external view returns (\n        uint256 amount,\n        uint256 stakedAt,\n        uint256 proofMinted\n    ) {\n        LibAppStorage.StakeInfo storage info = LibAppStorage.appStorage().stakes[user];\n        return (info.amount, info.stakedAt, info.proofMinted);\n    }\n\n    /**\n     * @notice Get total amount staked across all users\n     */\n    function getTotalStaked() external view returns (uint256) {\n        return LibAppStorage.appStorage().totalStaked;\n    }\n\n    /**\n     * @notice Check if user can unstake\n     */\n    function canUnstake(address user) external view returns (bool canUnstakeNow, uint256 timeRemaining) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        uint256 requestTime = s.unstakeRequestTime[user];\n        \n        if (requestTime == 0) {\n            return (false, 0);\n        }\n        \n        uint256 unlockTime = requestTime + s.unstakeCooldown;\n        \n        if (block.timestamp >= unlockTime) {\n            return (true, 0);\n        } else {\n            return (false, unlockTime - block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Calculate how much PROOF would be minted for staking\n     * @param btlAmount Amount of 2BTL to stake\n     * @return proofAmount Amount of PROOF that would be minted\n     */\n    function calculateProofMint(uint256 btlAmount) public view returns (uint256) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        // Base calculation: BTL * slope\n        uint256 baseProof = (btlAmount * s.bondingCurveSlope) / LibAppStorage.BASIS_POINTS;\n        \n        // Adjust based on collateralization ratio\n        uint256 currentRatio = _getCurrentCollateralRatio();\n        uint256 targetRatio = s.targetCollateralRatio > 0 ? s.targetCollateralRatio : LibAppStorage.BASIS_POINTS;\n        uint256 adjustment = (currentRatio * LibAppStorage.BASIS_POINTS) / targetRatio;\n        \n        uint256 adjustedProof = (baseProof * adjustment) / LibAppStorage.BASIS_POINTS;\n        \n        // Convert from 18 decimals (2BTL) to 6 decimals (PROOF)\n        return adjustedProof / 1e12;\n    }\n\n    /**\n     * @notice Get current staking APY\n     */\n    function getStakingAPY() external view returns (uint256) {\n        return LibAppStorage.appStorage().stakingAPY;\n    }\n\n    /**\n     * @notice Get unstake cooldown period\n     */\n    function getUnstakeCooldown() external view returns (uint256) {\n        return LibAppStorage.appStorage().unstakeCooldown;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Update the bonding curve slope\n     */\n    function updateBondingCurve(uint256 newSlope) external {\n        LibAppStorage.enforceIsAdmin();\n        require(newSlope > 0 && newSlope <= 10000, \"Staking: Invalid slope\");\n        \n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        s.bondingCurveSlope = newSlope;\n        s.lastBondingCurveUpdate = block.timestamp;\n        \n        emit BondingCurveUpdated(newSlope);\n    }\n\n    /**\n     * @notice Set the unstake cooldown period\n     */\n    function setUnstakeCooldown(uint256 cooldownSeconds) external {\n        LibAppStorage.enforceIsAdmin();\n        require(cooldownSeconds >= 1 days && cooldownSeconds <= 30 days, \"Staking: Invalid cooldown\");\n        \n        LibAppStorage.appStorage().unstakeCooldown = cooldownSeconds;\n    }\n\n    /**\n     * @notice Set staking APY\n     */\n    function setStakingAPY(uint256 apyBasisPoints) external {\n        LibAppStorage.enforceIsAdmin();\n        require(apyBasisPoints <= 5000, \"Staking: APY too high\"); // Max 50%\n        \n        LibAppStorage.appStorage().stakingAPY = apyBasisPoints;\n    }\n\n    /**\n     * @notice Pause/unpause staking\n     */\n    function setStakingPaused(bool paused) external {\n        LibAppStorage.enforceIsAdmin();\n        LibAppStorage.appStorage().stakingPaused = paused;\n    }\n\n    // ============ Internal Functions ============\n\n    function _getCurrentCollateralRatio() internal view returns (uint256) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        if (s.proofTotalSupply == 0) {\n            return s.targetCollateralRatio > 0 ? s.targetCollateralRatio : LibAppStorage.BASIS_POINTS;\n        }\n        \n        uint256 totalCollateral = s.treasuryUSDC + s.treasuryDAI;\n        return (totalCollateral * LibAppStorage.BASIS_POINTS) / s.proofTotalSupply;\n    }\n}\n"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibAppStorage\n * @notice Defines the shared storage structure for all 2bottles facets\n * @dev Uses the \"AppStorage\" pattern where all app data lives in one struct\n *      This struct is stored at a specific storage slot to avoid collisions\n *      \n *      WHY THIS PATTERN?\n *      - All facets can access the same data\n *      - No storage collisions between facets\n *      - Easy to see all state in one place\n *      - More gas efficient than multiple storage reads\n */\nlibrary LibAppStorage {\n    // ============ Storage Position ============\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"2bottles.app.storage\");\n\n    // ============ Constants ============\n    uint256 constant BASIS_POINTS = 10000; // For percentage calculations (100% = 10000)\n    uint256 constant SECONDS_PER_DAY = 86400;\n    uint256 constant BLOCKS_PER_DAY = 7200; // Assuming ~12 sec blocks\n\n    // ============ Role Constants ============\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 constant VENUE_MANAGER_ROLE = keccak256(\"VENUE_MANAGER_ROLE\");\n    bytes32 constant TREASURY_MANAGER_ROLE = keccak256(\"TREASURY_MANAGER_ROLE\");\n\n    // ============ Structs ============\n\n    /**\n     * @dev Information about a user's stake\n     */\n    struct StakeInfo {\n        uint256 amount;\n        uint256 stakedAt;\n        uint256 proofMinted;\n        uint256 lastRewardUpdate;\n    }\n\n    /**\n     * @dev Information about a user's rewards\n     */\n    struct RewardInfo {\n        uint256 totalEarned;\n        uint256 lastCheckIn;\n        uint256 checkInCount;\n        uint256 referralCount;\n    }\n\n    /**\n     * @dev Information about a venue\n     */\n    struct VenueInfo {\n        bool isActive;\n        uint256 multiplier;\n        uint256 totalCheckIns;\n        uint256 rewardsDistributed;\n    }\n\n    /**\n     * @dev Information about a governance proposal\n     */\n    struct Proposal {\n        address proposer;\n        string description;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 startBlock;\n        uint256 endBlock;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev Tracks voting on a proposal\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint256 votes;\n    }\n\n    /**\n     * @dev Checkpoint for vote delegation\n     */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /**\n     * @dev The main application storage struct\n     */\n    struct AppStorage {\n        // ============ 2BTL Token State ============\n        string btlName;\n        string btlSymbol;\n        uint8 btlDecimals;\n        uint256 btlTotalSupply;\n        mapping(address => uint256) btlBalances;\n        mapping(address => mapping(address => uint256)) btlAllowances;\n        uint256 btlTransferFee; // Basis points (50 = 0.5%)\n\n        // ============ PROOF Token State ============\n        string proofName;\n        string proofSymbol;\n        uint8 proofDecimals;\n        uint256 proofTotalSupply;\n        mapping(address => uint256) proofBalances;\n        mapping(address => mapping(address => uint256)) proofAllowances;\n\n        // ============ Staking State ============\n        mapping(address => StakeInfo) stakes;\n        uint256 totalStaked;\n        uint256 stakingAPY; // Basis points (1000 = 10%)\n        uint256 unstakeCooldown;\n        mapping(address => uint256) unstakeRequestTime;\n\n        // ============ Rewards State ============\n        mapping(address => RewardInfo) rewardInfo;\n        mapping(bytes32 => bool) usedCheckInHashes;\n        uint256 baseCheckInReward;\n        uint256 groupMultiplier;\n        uint256 maxCheckInsPerDay;\n        mapping(address => VenueInfo) venues;\n        address[] venueList;\n\n        // ============ Treasury State ============\n        uint256 treasuryUSDC;\n        uint256 treasuryDAI;\n        uint256 minCollateralRatio;\n        uint256 targetCollateralRatio;\n        address usdcAddress;\n        address daiAddress;\n\n        // ============ Governance State ============\n        mapping(uint256 => Proposal) proposals;\n        uint256 proposalCount;\n        mapping(uint256 => mapping(address => Receipt)) receipts;\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumVotes;\n        mapping(address => address) delegates;\n        mapping(address => uint256) numCheckpoints;\n        mapping(address => mapping(uint256 => Checkpoint)) checkpoints;\n\n        // ============ Access Control ============\n        mapping(bytes32 => mapping(address => bool)) roles;\n\n        // ============ Emergency State ============\n        bool paused;\n        bool stakingPaused;\n        bool rewardsPaused;\n\n        // ============ Bonding Curve State ============\n        uint256 bondingCurveSlope;\n        uint256 lastBondingCurveUpdate;\n\n        // ============ Anti-Gaming ============\n        mapping(address => mapping(uint256 => uint256)) dailyCheckIns;\n        mapping(address => uint256) lastCheckInBlock;\n\n        // ============ Stats & Analytics ============\n        uint256 totalCheckIns;\n        uint256 totalRewardsDistributed;\n        uint256 totalProofMinted;\n        uint256 totalProofRedeemed;\n    }\n\n    // ============ Storage Access ============\n\n    /**\n     * @notice Get the app storage struct\n     */\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ============ Role Modifiers ============\n\n    function enforceIsAdmin() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ADMIN_ROLE][msg.sender], \"LibAppStorage: Must be admin\");\n    }\n\n    function enforceIsOracle() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ORACLE_ROLE][msg.sender], \"LibAppStorage: Must be oracle\");\n    }\n\n    function enforceNotPaused() internal view {\n        require(!appStorage().paused, \"LibAppStorage: Contract is paused\");\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return appStorage().roles[role][account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = true;\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = false;\n    }\n}\n"
      }
    }
  }
}