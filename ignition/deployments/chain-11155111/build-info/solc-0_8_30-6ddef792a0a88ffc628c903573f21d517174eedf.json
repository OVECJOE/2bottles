{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-6ddef792a0a88ffc628c903573f21d517174eedf",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/facets/RewardsFacet.sol": "project/contracts/facets/RewardsFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/RewardsFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../libraries/LibAppStorage.sol\";\n\n/**\n * @title RewardsFacet\n * @notice Manages check-in rewards for dining at partner venues\n * @dev This is how users earn 2BTL tokens!\n *      \n *      REWARD SYSTEM:\n *      - Base reward: 100 2BTL per check-in\n *      - Group multiplier: +50% for 4+ people\n *      - Venue multiplier: Set by venue (happy hour = 2x)\n *      - First-time bonus: +100% for first visit\n *      \n *      ANTI-GAMING MEASURES:\n *      - Max check-ins per day per user\n *      - Unique check-in hash (prevents replay)\n *      - Oracle signature required (prevents fake check-ins)\n */\ncontract RewardsFacet {\n    \n    // ============ Events ============\n    event CheckInReward(\n        address indexed user,\n        address indexed venue,\n        uint256 baseReward,\n        uint256 multiplier,\n        uint256 totalReward\n    );\n    event VenueAdded(address indexed venue, uint256 multiplier);\n    event VenueUpdated(address indexed venue, uint256 multiplier, bool isActive);\n    event ReferralReward(address indexed referrer, address indexed referee, uint256 reward);\n\n    // ============ Check-In Functions ============\n\n    /**\n     * @notice Record a check-in and distribute rewards\n     * @param user The user checking in\n     * @param venue The venue address\n     * @param groupSize Number of people in the group\n     * @param checkInHash Unique hash to prevent replay\n     * @dev Only callable by ORACLE (backend server)\n     */\n    function recordCheckIn(\n        address user,\n        address venue,\n        uint256 groupSize,\n        bytes32 checkInHash\n    ) external returns (uint256 rewardAmount) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceIsOracle();\n        LibAppStorage.enforceNotPaused();\n        require(!s.rewardsPaused, \"Rewards: Rewards are paused\");\n        require(user != address(0), \"Rewards: Invalid user\");\n        require(venue != address(0), \"Rewards: Invalid venue\");\n        \n        // Venue must be active\n        require(s.venues[venue].isActive, \"Rewards: Venue not active\");\n        \n        // Prevent replay attacks\n        require(!s.usedCheckInHashes[checkInHash], \"Rewards: Check-in already processed\");\n        s.usedCheckInHashes[checkInHash] = true;\n        \n        // Anti-gaming: Max check-ins per day\n        uint256 today = block.timestamp / LibAppStorage.SECONDS_PER_DAY;\n        require(\n            s.dailyCheckIns[user][today] < s.maxCheckInsPerDay,\n            \"Rewards: Max check-ins per day reached\"\n        );\n        s.dailyCheckIns[user][today]++;\n        \n        // Prevent same-block check-ins (flash loan protection)\n        require(s.lastCheckInBlock[user] != block.number, \"Rewards: Already checked in this block\");\n        s.lastCheckInBlock[user] = block.number;\n        \n        // Calculate reward\n        rewardAmount = _calculateReward(user, venue, groupSize);\n        \n        // Update user stats\n        LibAppStorage.RewardInfo storage rewardInfo = s.rewardInfo[user];\n        rewardInfo.totalEarned += rewardAmount;\n        rewardInfo.lastCheckIn = block.timestamp;\n        rewardInfo.checkInCount++;\n        \n        // Update venue stats\n        s.venues[venue].totalCheckIns++;\n        s.venues[venue].rewardsDistributed += rewardAmount;\n        \n        // Update global stats\n        s.totalCheckIns++;\n        s.totalRewardsDistributed += rewardAmount;\n        \n        // Mint 2BTL rewards\n        s.btlBalances[user] += rewardAmount;\n        s.btlTotalSupply += rewardAmount;\n        \n        emit CheckInReward(\n            user,\n            venue,\n            s.baseCheckInReward,\n            s.venues[venue].multiplier,\n            rewardAmount\n        );\n    }\n\n    /**\n     * @notice Claim referral reward when a friend makes their first check-in\n     */\n    function claimReferralReward(address referrer, address referee) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceIsOracle();\n        LibAppStorage.enforceNotPaused();\n        require(!s.rewardsPaused, \"Rewards: Rewards are paused\");\n        \n        // Referee must have checked in at least once\n        require(s.rewardInfo[referee].checkInCount > 0, \"Rewards: Referee has not checked in\");\n        \n        uint256 referralReward = s.baseCheckInReward / 2; // 50 2BTL\n        \n        // Update referrer stats\n        s.rewardInfo[referrer].referralCount++;\n        s.rewardInfo[referrer].totalEarned += referralReward;\n        \n        // Mint reward\n        s.btlBalances[referrer] += referralReward;\n        s.btlTotalSupply += referralReward;\n        \n        emit ReferralReward(referrer, referee, referralReward);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get reward info for a user\n     */\n    function getRewardInfo(address user) external view returns (\n        uint256 totalEarned,\n        uint256 lastCheckIn,\n        uint256 checkInCount,\n        uint256 referralCount\n    ) {\n        LibAppStorage.RewardInfo storage info = LibAppStorage.appStorage().rewardInfo[user];\n        return (\n            info.totalEarned,\n            info.lastCheckIn,\n            info.checkInCount,\n            info.referralCount\n        );\n    }\n\n    /**\n     * @notice Estimate reward for a check-in\n     */\n    function estimateReward(\n        address user,\n        address venue,\n        uint256 groupSize\n    ) external view returns (uint256) {\n        return _calculateReward(user, venue, groupSize);\n    }\n\n    /**\n     * @notice Get venue information\n     */\n    function getVenueInfo(address venue) external view returns (\n        bool isActive,\n        uint256 multiplier,\n        uint256 totalCheckIns,\n        uint256 rewardsDistributed\n    ) {\n        LibAppStorage.VenueInfo storage info = LibAppStorage.appStorage().venues[venue];\n        return (\n            info.isActive,\n            info.multiplier,\n            info.totalCheckIns,\n            info.rewardsDistributed\n        );\n    }\n\n    /**\n     * @notice Get all active venues\n     */\n    function getActiveVenues() external view returns (address[] memory venues) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        // Count active venues\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < s.venueList.length; i++) {\n            if (s.venues[s.venueList[i]].isActive) {\n                activeCount++;\n            }\n        }\n        \n        // Build array\n        venues = new address[](activeCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < s.venueList.length; i++) {\n            if (s.venues[s.venueList[i]].isActive) {\n                venues[index] = s.venueList[i];\n                index++;\n            }\n        }\n    }\n\n    /**\n     * @notice Get user's check-ins today\n     */\n    function getCheckInsToday(address user) external view returns (uint256) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        uint256 today = block.timestamp / LibAppStorage.SECONDS_PER_DAY;\n        return s.dailyCheckIns[user][today];\n    }\n\n    /**\n     * @notice Get global stats\n     */\n    function getGlobalStats() external view returns (\n        uint256 totalCheckIns,\n        uint256 totalRewardsDistributed,\n        uint256 totalProofMinted,\n        uint256 totalProofRedeemed\n    ) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        return (\n            s.totalCheckIns,\n            s.totalRewardsDistributed,\n            s.totalProofMinted,\n            s.totalProofRedeemed\n        );\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Add a new venue\n     */\n    function addVenue(address venue, uint256 multiplier) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(\n            s.roles[LibAppStorage.VENUE_MANAGER_ROLE][msg.sender] || \n            s.roles[LibAppStorage.ADMIN_ROLE][msg.sender],\n            \"Rewards: Not authorized\"\n        );\n        require(venue != address(0), \"Rewards: Invalid venue address\");\n        require(multiplier >= 50 && multiplier <= 500, \"Rewards: Multiplier must be 0.5x to 5x\");\n        \n        s.venues[venue] = LibAppStorage.VenueInfo({\n            isActive: true,\n            multiplier: multiplier,\n            totalCheckIns: 0,\n            rewardsDistributed: 0\n        });\n        \n        s.venueList.push(venue);\n        \n        emit VenueAdded(venue, multiplier);\n    }\n\n    /**\n     * @notice Update venue settings\n     */\n    function updateVenue(address venue, uint256 multiplier, bool isActive) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(\n            s.roles[LibAppStorage.VENUE_MANAGER_ROLE][msg.sender] || \n            s.roles[LibAppStorage.ADMIN_ROLE][msg.sender],\n            \"Rewards: Not authorized\"\n        );\n        require(multiplier >= 50 && multiplier <= 500, \"Rewards: Multiplier must be 0.5x to 5x\");\n        \n        s.venues[venue].multiplier = multiplier;\n        s.venues[venue].isActive = isActive;\n        \n        emit VenueUpdated(venue, multiplier, isActive);\n    }\n\n    /**\n     * @notice Set base check-in reward\n     */\n    function setBaseCheckInReward(uint256 baseReward) external {\n        LibAppStorage.enforceIsAdmin();\n        require(baseReward > 0 && baseReward <= 1000 * 1e18, \"Rewards: Invalid base reward\");\n        \n        LibAppStorage.appStorage().baseCheckInReward = baseReward;\n    }\n\n    /**\n     * @notice Set max check-ins per day\n     */\n    function setMaxCheckInsPerDay(uint256 maxCheckIns) external {\n        LibAppStorage.enforceIsAdmin();\n        require(maxCheckIns >= 1 && maxCheckIns <= 10, \"Rewards: Must be 1-10\");\n        \n        LibAppStorage.appStorage().maxCheckInsPerDay = maxCheckIns;\n    }\n\n    /**\n     * @notice Set group multiplier\n     */\n    function setGroupMultiplier(uint256 multiplier) external {\n        LibAppStorage.enforceIsAdmin();\n        require(multiplier >= 100 && multiplier <= 300, \"Rewards: Multiplier 1x-3x\");\n        \n        LibAppStorage.appStorage().groupMultiplier = multiplier;\n    }\n\n    /**\n     * @notice Pause/unpause rewards\n     */\n    function setRewardsPaused(bool paused) external {\n        LibAppStorage.enforceIsAdmin();\n        LibAppStorage.appStorage().rewardsPaused = paused;\n    }\n\n    // ============ Internal Functions ============\n\n    function _calculateReward(\n        address user,\n        address venue,\n        uint256 groupSize\n    ) internal view returns (uint256 reward) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        // Start with base reward\n        reward = s.baseCheckInReward;\n        \n        // Apply venue multiplier (100 = 1x)\n        reward = (reward * s.venues[venue].multiplier) / 100;\n        \n        // Apply group multiplier (50% bonus for 4+ people)\n        if (groupSize >= 4) {\n            reward = (reward * s.groupMultiplier) / 100;\n        }\n        \n        // First-time bonus (100% bonus for first check-in)\n        if (s.rewardInfo[user].checkInCount == 0) {\n            reward = reward * 2;\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibAppStorage\n * @notice Defines the shared storage structure for all 2bottles facets\n * @dev Uses the \"AppStorage\" pattern where all app data lives in one struct\n *      This struct is stored at a specific storage slot to avoid collisions\n *      \n *      WHY THIS PATTERN?\n *      - All facets can access the same data\n *      - No storage collisions between facets\n *      - Easy to see all state in one place\n *      - More gas efficient than multiple storage reads\n */\nlibrary LibAppStorage {\n    // ============ Storage Position ============\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"2bottles.app.storage\");\n\n    // ============ Constants ============\n    uint256 constant BASIS_POINTS = 10000; // For percentage calculations (100% = 10000)\n    uint256 constant SECONDS_PER_DAY = 86400;\n    uint256 constant BLOCKS_PER_DAY = 7200; // Assuming ~12 sec blocks\n\n    // ============ Role Constants ============\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 constant VENUE_MANAGER_ROLE = keccak256(\"VENUE_MANAGER_ROLE\");\n    bytes32 constant TREASURY_MANAGER_ROLE = keccak256(\"TREASURY_MANAGER_ROLE\");\n\n    // ============ Structs ============\n\n    /**\n     * @dev Information about a user's stake\n     */\n    struct StakeInfo {\n        uint256 amount;\n        uint256 stakedAt;\n        uint256 proofMinted;\n        uint256 lastRewardUpdate;\n    }\n\n    /**\n     * @dev Information about a user's rewards\n     */\n    struct RewardInfo {\n        uint256 totalEarned;\n        uint256 lastCheckIn;\n        uint256 checkInCount;\n        uint256 referralCount;\n    }\n\n    /**\n     * @dev Information about a venue\n     */\n    struct VenueInfo {\n        bool isActive;\n        uint256 multiplier;\n        uint256 totalCheckIns;\n        uint256 rewardsDistributed;\n    }\n\n    /**\n     * @dev Information about a governance proposal\n     */\n    struct Proposal {\n        address proposer;\n        string description;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 startBlock;\n        uint256 endBlock;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev Tracks voting on a proposal\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint256 votes;\n    }\n\n    /**\n     * @dev Checkpoint for vote delegation\n     */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /**\n     * @dev The main application storage struct\n     */\n    struct AppStorage {\n        // ============ 2BTL Token State ============\n        string btlName;\n        string btlSymbol;\n        uint8 btlDecimals;\n        uint256 btlTotalSupply;\n        mapping(address => uint256) btlBalances;\n        mapping(address => mapping(address => uint256)) btlAllowances;\n        uint256 btlTransferFee; // Basis points (50 = 0.5%)\n\n        // ============ PROOF Token State ============\n        string proofName;\n        string proofSymbol;\n        uint8 proofDecimals;\n        uint256 proofTotalSupply;\n        mapping(address => uint256) proofBalances;\n        mapping(address => mapping(address => uint256)) proofAllowances;\n\n        // ============ Staking State ============\n        mapping(address => StakeInfo) stakes;\n        uint256 totalStaked;\n        uint256 stakingAPY; // Basis points (1000 = 10%)\n        uint256 unstakeCooldown;\n        mapping(address => uint256) unstakeRequestTime;\n\n        // ============ Rewards State ============\n        mapping(address => RewardInfo) rewardInfo;\n        mapping(bytes32 => bool) usedCheckInHashes;\n        uint256 baseCheckInReward;\n        uint256 groupMultiplier;\n        uint256 maxCheckInsPerDay;\n        mapping(address => VenueInfo) venues;\n        address[] venueList;\n\n        // ============ Treasury State ============\n        uint256 treasuryUSDC;\n        uint256 treasuryDAI;\n        uint256 minCollateralRatio;\n        uint256 targetCollateralRatio;\n        address usdcAddress;\n        address daiAddress;\n\n        // ============ Governance State ============\n        mapping(uint256 => Proposal) proposals;\n        uint256 proposalCount;\n        mapping(uint256 => mapping(address => Receipt)) receipts;\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumVotes;\n        mapping(address => address) delegates;\n        mapping(address => uint256) numCheckpoints;\n        mapping(address => mapping(uint256 => Checkpoint)) checkpoints;\n\n        // ============ Access Control ============\n        mapping(bytes32 => mapping(address => bool)) roles;\n\n        // ============ Emergency State ============\n        bool paused;\n        bool stakingPaused;\n        bool rewardsPaused;\n\n        // ============ Bonding Curve State ============\n        uint256 bondingCurveSlope;\n        uint256 lastBondingCurveUpdate;\n\n        // ============ Anti-Gaming ============\n        mapping(address => mapping(uint256 => uint256)) dailyCheckIns;\n        mapping(address => uint256) lastCheckInBlock;\n\n        // ============ Stats & Analytics ============\n        uint256 totalCheckIns;\n        uint256 totalRewardsDistributed;\n        uint256 totalProofMinted;\n        uint256 totalProofRedeemed;\n    }\n\n    // ============ Storage Access ============\n\n    /**\n     * @notice Get the app storage struct\n     */\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ============ Role Modifiers ============\n\n    function enforceIsAdmin() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ADMIN_ROLE][msg.sender], \"LibAppStorage: Must be admin\");\n    }\n\n    function enforceIsOracle() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ORACLE_ROLE][msg.sender], \"LibAppStorage: Must be oracle\");\n    }\n\n    function enforceNotPaused() internal view {\n        require(!appStorage().paused, \"LibAppStorage: Contract is paused\");\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return appStorage().roles[role][account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = true;\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = false;\n    }\n}\n"
      }
    }
  }
}