{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-22e083d90b7bef4dd59ae64dfbe8b1832580ec55",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/facets/OwnershipFacet.sol": "project/contracts/facets/OwnershipFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/OwnershipFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n}\n"
      },
      "project/contracts/interfaces/IDiamondCut.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDiamondCut {\n    enum FacetCutAction { Add, Replace, Remove }\n\n    // Add = 0, Replace = 1, Remove = 2\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _cut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    function diamondCut(FacetCut[] calldata _cut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _cut, address _init, bytes _calldata);\n}\n"
      },
      "project/contracts/interfaces/IDiamondLoupe.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDiamondLoupe {\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// These functions are expected to be called frequently by tools.\n    function facets() external view returns (Facet[] memory);\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);\n    function facetAddresses() external view returns (address[] memory);\n    function facetAddress(bytes4 _functionSelector) external view returns (address);\n}\n"
      },
      "project/contracts/interfaces/IERC173.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function owner() external view returns (address owner_);\n    function transferOwnership(address _newOwner) external;\n}\n"
      },
      "project/contracts/libraries/LibDiamond.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IDiamondLoupe.sol\";\n\n/**\n * @title LibDiamond\n * @notice Core library for the Diamond Pattern (EIP-2535)\n * @dev This library manages:\n *      - Facet addresses and function selectors\n *      - DiamondCut operations (add/replace/remove facets)\n *      - Contract ownership\n */\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // selector => facetAddress and selector position in facetFunctionSelectors\n        mapping(bytes4 => FacetAddressAndSelectorPosition) selectorToFacetAndPosition;\n        // facetAddress => function selectors\n        mapping(address => bytes4[]) facetFunctionSelectors;\n        // list of facet addresses\n        address[] facetAddresses;\n        // owner\n        address contractOwner;\n        // supported interfaces (ERC-165)\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    // ============ Events ============\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // ============ Custom Errors ============\n    error NotContractOwner(address user, address owner);\n    error NoSelectorsProvided();\n    error CannotAddSelectorsToZeroAddress();\n    error FunctionAlreadyExists(bytes4 selector);\n    error CannotReplaceFunctionsFromZeroAddress();\n    error CannotReplaceWithSameFunction(bytes4 selector);\n    error FunctionDoesNotExist(bytes4 selector);\n    error RemoveFacetAddressMustBeZero();\n    error InitializationFailed(address init, bytes data);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address) {\n        return diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n        }\n    }\n\n    /**\n     * @notice Main function to perform diamond cuts\n     */\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[i].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[i].facetAddress, _diamondCut[i].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[i].facetAddress, _diamondCut[i].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(address(0), _diamondCut[i].functionSelectors);\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress == address(0)) revert CannotAddSelectorsToZeroAddress();\n        \n        DiamondStorage storage ds = diamondStorage();\n        enforceHasContractCode(_facetAddress);\n\n        // if this is a new facet, add to facetAddresses\n        if (ds.facetFunctionSelectors[_facetAddress].length == 0) {\n            ds.facetAddresses.push(_facetAddress);\n        }\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            if (ds.selectorToFacetAndPosition[selector].facetAddress != address(0)) {\n                revert FunctionAlreadyExists(selector);\n            }\n            ds.facetFunctionSelectors[_facetAddress].push(selector);\n            ds.selectorToFacetAndPosition[selector] = FacetAddressAndSelectorPosition({\n                facetAddress: _facetAddress,\n                selectorPosition: uint16(ds.facetFunctionSelectors[_facetAddress].length - 1)\n            });\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress == address(0)) revert CannotReplaceFunctionsFromZeroAddress();\n        \n        DiamondStorage storage ds = diamondStorage();\n        enforceHasContractCode(_facetAddress);\n\n        if (ds.facetFunctionSelectors[_facetAddress].length == 0) {\n            ds.facetAddresses.push(_facetAddress);\n        }\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\n            if (oldFacet == _facetAddress) revert CannotReplaceWithSameFunction(selector);\n            if (oldFacet == address(0)) revert FunctionDoesNotExist(selector);\n\n            // remove selector from old facet\n            bytes4[] storage oldSelectors = ds.facetFunctionSelectors[oldFacet];\n            uint16 selectorPos = ds.selectorToFacetAndPosition[selector].selectorPosition;\n            uint256 lastPos = oldSelectors.length - 1;\n            if (selectorPos != lastPos) {\n                bytes4 lastSelector = oldSelectors[lastPos];\n                oldSelectors[selectorPos] = lastSelector;\n                ds.selectorToFacetAndPosition[lastSelector].selectorPosition = selectorPos;\n            }\n            oldSelectors.pop();\n\n            // add selector to new facet\n            ds.facetFunctionSelectors[_facetAddress].push(selector);\n            ds.selectorToFacetAndPosition[selector] = FacetAddressAndSelectorPosition({\n                facetAddress: _facetAddress,\n                selectorPosition: uint16(ds.facetFunctionSelectors[_facetAddress].length - 1)\n            });\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _selectors) internal {\n        if (_selectors.length == 0) revert NoSelectorsProvided();\n        if (_facetAddress != address(0)) revert RemoveFacetAddressMustBeZero();\n        \n        DiamondStorage storage ds = diamondStorage();\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            FacetAddressAndSelectorPosition memory old = ds.selectorToFacetAndPosition[selector];\n            address oldFacet = old.facetAddress;\n            if (oldFacet == address(0)) revert FunctionDoesNotExist(selector);\n\n            // remove selector from old facet\n            bytes4[] storage oldSelectors = ds.facetFunctionSelectors[oldFacet];\n            uint256 lastPos = oldSelectors.length - 1;\n            uint16 selectorPos = old.selectorPosition;\n            if (selectorPos != lastPos) {\n                bytes4 lastSelector = oldSelectors[lastPos];\n                oldSelectors[selectorPos] = lastSelector;\n                ds.selectorToFacetAndPosition[lastSelector].selectorPosition = selectorPos;\n            }\n            oldSelectors.pop();\n            delete ds.selectorToFacetAndPosition[selector];\n\n            // if no selectors left for facet, remove facetAddress\n            if (oldSelectors.length == 0) {\n                uint256 len = ds.facetAddresses.length;\n                for (uint256 j = 0; j < len; j++) {\n                    if (ds.facetAddresses[j] == oldFacet) {\n                        uint256 last = ds.facetAddresses.length - 1;\n                        if (j != last) {\n                            ds.facetAddresses[j] = ds.facetAddresses[last];\n                        }\n                        ds.facetAddresses.pop();\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamond: _calldata must be empty if _init is zero\");\n            return;\n        }\n        enforceHasContractCode(_init);\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let size := mload(error)\n                    revert(add(32, error), size)\n                }\n            }\n            revert InitializationFailed(_init, _calldata);\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, \"LibDiamond: Address has no code\");\n    }\n\n    function setSupportedInterface(bytes4 _interfaceId, bool _supported) internal {\n        diamondStorage().supportedInterfaces[_interfaceId] = _supported;\n    }\n\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\n        return diamondStorage().supportedInterfaces[_interfaceId];\n    }\n}"
      }
    }
  }
}