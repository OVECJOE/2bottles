{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-b6aefdcd2c2c791ebaaf90fe82232cc6b8631c3d",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/facets/GovernanceFacet.sol": "project/contracts/facets/GovernanceFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/GovernanceFacet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../libraries/LibAppStorage.sol\";\n\n/**\n * @title GovernanceFacet\n * @notice DAO governance for 2bottles protocol\n * @dev Token holders can create and vote on proposals\n *      \n *      GOVERNANCE PROCESS:\n *      1. User creates proposal (needs minimum 2BTL)\n *      2. Voting delay (e.g., 1 day)\n *      3. Voting period (e.g., 3 days)\n *      4. If quorum reached and majority yes â†’ proposal passes\n *      5. Admin executes proposal\n *      \n *      VOTING POWER:\n *      - 1 2BTL = 1 vote\n *      - Can delegate votes to others\n */\ncontract GovernanceFacet {\n    \n    // ============ Events ============\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        string description,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n    event VoteCast(\n        address indexed voter,\n        uint256 indexed proposalId,\n        bool support,\n        uint256 votes\n    );\n    event ProposalExecuted(uint256 indexed proposalId);\n    event ProposalCanceled(uint256 indexed proposalId);\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    // ============ Proposal Functions ============\n\n    /**\n     * @notice Create a new proposal\n     * @param description Description of the proposal\n     * @return proposalId The ID of the created proposal\n     */\n    function propose(string memory description) external returns (uint256 proposalId) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(bytes(description).length > 0, \"Governance: Empty description\");\n        require(s.btlBalances[msg.sender] >= s.proposalThreshold, \"Governance: Below proposal threshold\");\n        \n        proposalId = s.proposalCount++;\n        \n        LibAppStorage.Proposal storage proposal = s.proposals[proposalId];\n        proposal.proposer = msg.sender;\n        proposal.description = description;\n        proposal.startBlock = block.number + s.votingDelay;\n        proposal.endBlock = proposal.startBlock + s.votingPeriod;\n        proposal.forVotes = 0;\n        proposal.againstVotes = 0;\n        proposal.executed = false;\n        proposal.canceled = false;\n        \n        emit ProposalCreated(\n            proposalId,\n            msg.sender,\n            description,\n            proposal.startBlock,\n            proposal.endBlock\n        );\n    }\n\n    /**\n     * @notice Cast a vote on a proposal\n     * @param proposalId The proposal to vote on\n     * @param support True for yes, false for no\n     */\n    function castVote(uint256 proposalId, bool support) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(proposalId < s.proposalCount, \"Governance: Invalid proposal\");\n        \n        LibAppStorage.Proposal storage proposal = s.proposals[proposalId];\n        require(!proposal.executed, \"Governance: Proposal already executed\");\n        require(!proposal.canceled, \"Governance: Proposal canceled\");\n        require(block.number >= proposal.startBlock, \"Governance: Voting not started\");\n        require(block.number <= proposal.endBlock, \"Governance: Voting ended\");\n        \n        LibAppStorage.Receipt storage receipt = s.receipts[proposalId][msg.sender];\n        require(!receipt.hasVoted, \"Governance: Already voted\");\n        \n        // Get voting power (current 2BTL balance)\n        uint256 votes = s.btlBalances[msg.sender];\n        require(votes > 0, \"Governance: No voting power\");\n        \n        // Record vote\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n        \n        // Update proposal tallies\n        if (support) {\n            proposal.forVotes += votes;\n        } else {\n            proposal.againstVotes += votes;\n        }\n        \n        emit VoteCast(msg.sender, proposalId, support, votes);\n    }\n\n    /**\n     * @notice Execute a passed proposal\n     */\n    function execute(uint256 proposalId) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(s.roles[LibAppStorage.ADMIN_ROLE][msg.sender], \"Governance: Only admin can execute\");\n        require(proposalId < s.proposalCount, \"Governance: Invalid proposal\");\n        \n        LibAppStorage.Proposal storage proposal = s.proposals[proposalId];\n        require(!proposal.executed, \"Governance: Already executed\");\n        require(!proposal.canceled, \"Governance: Proposal canceled\");\n        require(block.number > proposal.endBlock, \"Governance: Voting not ended\");\n        \n        // Check quorum\n        uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\n        require(totalVotes >= s.quorumVotes, \"Governance: Quorum not reached\");\n        \n        // Check majority\n        require(proposal.forVotes > proposal.againstVotes, \"Governance: Proposal defeated\");\n        \n        proposal.executed = true;\n        \n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancel a proposal\n     */\n    function cancel(uint256 proposalId) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(proposalId < s.proposalCount, \"Governance: Invalid proposal\");\n        \n        LibAppStorage.Proposal storage proposal = s.proposals[proposalId];\n        require(!proposal.executed, \"Governance: Already executed\");\n        require(!proposal.canceled, \"Governance: Already canceled\");\n        require(\n            msg.sender == proposal.proposer || s.roles[LibAppStorage.ADMIN_ROLE][msg.sender],\n            \"Governance: Not authorized\"\n        );\n        \n        proposal.canceled = true;\n        \n        emit ProposalCanceled(proposalId);\n    }\n\n    // ============ Delegation Functions ============\n\n    /**\n     * @notice Delegate your voting power to another address\n     */\n    function delegate(address delegatee) external {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        LibAppStorage.enforceNotPaused();\n        require(delegatee != address(0), \"Governance: Cannot delegate to zero address\");\n        \n        address currentDelegate = s.delegates[msg.sender];\n        require(delegatee != currentDelegate, \"Governance: Already delegated to this address\");\n        \n        s.delegates[msg.sender] = delegatee;\n        \n        _moveDelegates(currentDelegate, delegatee, s.btlBalances[msg.sender]);\n        \n        emit DelegateChanged(msg.sender, currentDelegate, delegatee);\n    }\n\n    /**\n     * @notice Get the current delegate for an address\n     */\n    function getCurrentDelegate(address delegator) external view returns (address) {\n        return LibAppStorage.appStorage().delegates[delegator];\n    }\n\n    /**\n     * @notice Get current votes for an address (including delegated)\n     */\n    function getCurrentVotes(address account) external view returns (uint256) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        uint256 nCheckpoints = s.numCheckpoints[account];\n        return nCheckpoints > 0 ? s.checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get proposal details\n     */\n    function getProposal(uint256 proposalId) external view returns (\n        address proposer,\n        string memory description,\n        uint256 forVotes,\n        uint256 againstVotes,\n        uint256 startBlock,\n        uint256 endBlock,\n        bool executed,\n        bool canceled\n    ) {\n        require(proposalId < LibAppStorage.appStorage().proposalCount, \"Governance: Invalid proposal\");\n        \n        LibAppStorage.Proposal storage p = LibAppStorage.appStorage().proposals[proposalId];\n        return (\n            p.proposer,\n            p.description,\n            p.forVotes,\n            p.againstVotes,\n            p.startBlock,\n            p.endBlock,\n            p.executed,\n            p.canceled\n        );\n    }\n\n    /**\n     * @notice Get a user's vote receipt for a proposal\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (\n        bool hasVoted,\n        bool support,\n        uint256 votes\n    ) {\n        LibAppStorage.Receipt storage receipt = LibAppStorage.appStorage().receipts[proposalId][voter];\n        return (receipt.hasVoted, receipt.support, receipt.votes);\n    }\n\n    /**\n     * @notice Get proposal state\n     * @return 0=Pending, 1=Active, 2=Defeated, 3=Succeeded, 4=Executed, 5=Canceled\n     */\n    function getProposalState(uint256 proposalId) external view returns (uint8) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        require(proposalId < s.proposalCount, \"Governance: Invalid proposal\");\n        \n        LibAppStorage.Proposal storage proposal = s.proposals[proposalId];\n        \n        if (proposal.canceled) {\n            return 5; // Canceled\n        } else if (proposal.executed) {\n            return 4; // Executed\n        } else if (block.number <= proposal.startBlock) {\n            return 0; // Pending\n        } else if (block.number <= proposal.endBlock) {\n            return 1; // Active\n        } else {\n            // Voting ended, check result\n            uint256 totalVotes = proposal.forVotes + proposal.againstVotes;\n            if (totalVotes < s.quorumVotes || proposal.forVotes <= proposal.againstVotes) {\n                return 2; // Defeated\n            } else {\n                return 3; // Succeeded\n            }\n        }\n    }\n\n    /**\n     * @notice Get governance parameters\n     */\n    function getGovernanceParams() external view returns (\n        uint256 votingDelay,\n        uint256 votingPeriod,\n        uint256 proposalThreshold,\n        uint256 quorumVotes\n    ) {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        return (\n            s.votingDelay,\n            s.votingPeriod,\n            s.proposalThreshold,\n            s.quorumVotes\n        );\n    }\n\n    /**\n     * @notice Get total proposal count\n     */\n    function getProposalCount() external view returns (uint256) {\n        return LibAppStorage.appStorage().proposalCount;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Set governance parameters\n     */\n    function setGovernanceParams(\n        uint256 votingDelay_,\n        uint256 votingPeriod_,\n        uint256 proposalThreshold_,\n        uint256 quorumVotes_\n    ) external {\n        LibAppStorage.enforceIsAdmin();        \n        require(votingDelay_ >= 1 && votingDelay_ <= 50400, \"Governance: Invalid voting delay\");\n        require(votingPeriod_ >= 5760 && votingPeriod_ <= 100800, \"Governance: Invalid voting period\");\n        require(proposalThreshold_ > 0, \"Governance: Invalid proposal threshold\");\n        require(quorumVotes_ > 0, \"Governance: Invalid quorum\");\n        \n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        s.votingDelay = votingDelay_;\n        s.votingPeriod = votingPeriod_;\n        s.proposalThreshold = proposalThreshold_;\n        s.quorumVotes = quorumVotes_;\n    }\n\n    // ============ Internal Functions ============\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        \n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = uint32(s.numCheckpoints[srcRep]);\n                uint256 srcRepOld = srcRepNum > 0 ? s.checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld > amount ? srcRepOld - amount : 0;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = uint32(s.numCheckpoints[dstRep]);\n                uint256 dstRepOld = dstRepNum > 0 ? s.checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 newVotes\n    ) internal {\n        LibAppStorage.AppStorage storage s = LibAppStorage.appStorage();\n        uint32 blockNumber = uint32(block.number);\n\n        if (nCheckpoints > 0 && s.checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            s.checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            s.checkpoints[delegatee][nCheckpoints] = LibAppStorage.Checkpoint(blockNumber, newVotes);\n            s.numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title LibAppStorage\n * @notice Defines the shared storage structure for all 2bottles facets\n * @dev Uses the \"AppStorage\" pattern where all app data lives in one struct\n *      This struct is stored at a specific storage slot to avoid collisions\n *      \n *      WHY THIS PATTERN?\n *      - All facets can access the same data\n *      - No storage collisions between facets\n *      - Easy to see all state in one place\n *      - More gas efficient than multiple storage reads\n */\nlibrary LibAppStorage {\n    // ============ Storage Position ============\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"2bottles.app.storage\");\n\n    // ============ Constants ============\n    uint256 constant BASIS_POINTS = 10000; // For percentage calculations (100% = 10000)\n    uint256 constant SECONDS_PER_DAY = 86400;\n    uint256 constant BLOCKS_PER_DAY = 7200; // Assuming ~12 sec blocks\n\n    // ============ Role Constants ============\n    bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    bytes32 constant VENUE_MANAGER_ROLE = keccak256(\"VENUE_MANAGER_ROLE\");\n    bytes32 constant TREASURY_MANAGER_ROLE = keccak256(\"TREASURY_MANAGER_ROLE\");\n\n    // ============ Structs ============\n\n    /**\n     * @dev Information about a user's stake\n     */\n    struct StakeInfo {\n        uint256 amount;\n        uint256 stakedAt;\n        uint256 proofMinted;\n        uint256 lastRewardUpdate;\n    }\n\n    /**\n     * @dev Information about a user's rewards\n     */\n    struct RewardInfo {\n        uint256 totalEarned;\n        uint256 lastCheckIn;\n        uint256 checkInCount;\n        uint256 referralCount;\n    }\n\n    /**\n     * @dev Information about a venue\n     */\n    struct VenueInfo {\n        bool isActive;\n        uint256 multiplier;\n        uint256 totalCheckIns;\n        uint256 rewardsDistributed;\n    }\n\n    /**\n     * @dev Information about a governance proposal\n     */\n    struct Proposal {\n        address proposer;\n        string description;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 startBlock;\n        uint256 endBlock;\n        bool executed;\n        bool canceled;\n    }\n\n    /**\n     * @dev Tracks voting on a proposal\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint256 votes;\n    }\n\n    /**\n     * @dev Checkpoint for vote delegation\n     */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /**\n     * @dev The main application storage struct\n     */\n    struct AppStorage {\n        // ============ 2BTL Token State ============\n        string btlName;\n        string btlSymbol;\n        uint8 btlDecimals;\n        uint256 btlTotalSupply;\n        mapping(address => uint256) btlBalances;\n        mapping(address => mapping(address => uint256)) btlAllowances;\n        uint256 btlTransferFee; // Basis points (50 = 0.5%)\n\n        // ============ PROOF Token State ============\n        string proofName;\n        string proofSymbol;\n        uint8 proofDecimals;\n        uint256 proofTotalSupply;\n        mapping(address => uint256) proofBalances;\n        mapping(address => mapping(address => uint256)) proofAllowances;\n\n        // ============ Staking State ============\n        mapping(address => StakeInfo) stakes;\n        uint256 totalStaked;\n        uint256 stakingAPY; // Basis points (1000 = 10%)\n        uint256 unstakeCooldown;\n        mapping(address => uint256) unstakeRequestTime;\n\n        // ============ Rewards State ============\n        mapping(address => RewardInfo) rewardInfo;\n        mapping(bytes32 => bool) usedCheckInHashes;\n        uint256 baseCheckInReward;\n        uint256 groupMultiplier;\n        uint256 maxCheckInsPerDay;\n        mapping(address => VenueInfo) venues;\n        address[] venueList;\n\n        // ============ Treasury State ============\n        uint256 treasuryUSDC;\n        uint256 treasuryDAI;\n        uint256 minCollateralRatio;\n        uint256 targetCollateralRatio;\n        address usdcAddress;\n        address daiAddress;\n\n        // ============ Governance State ============\n        mapping(uint256 => Proposal) proposals;\n        uint256 proposalCount;\n        mapping(uint256 => mapping(address => Receipt)) receipts;\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumVotes;\n        mapping(address => address) delegates;\n        mapping(address => uint256) numCheckpoints;\n        mapping(address => mapping(uint256 => Checkpoint)) checkpoints;\n\n        // ============ Access Control ============\n        mapping(bytes32 => mapping(address => bool)) roles;\n\n        // ============ Emergency State ============\n        bool paused;\n        bool stakingPaused;\n        bool rewardsPaused;\n\n        // ============ Bonding Curve State ============\n        uint256 bondingCurveSlope;\n        uint256 lastBondingCurveUpdate;\n\n        // ============ Anti-Gaming ============\n        mapping(address => mapping(uint256 => uint256)) dailyCheckIns;\n        mapping(address => uint256) lastCheckInBlock;\n\n        // ============ Stats & Analytics ============\n        uint256 totalCheckIns;\n        uint256 totalRewardsDistributed;\n        uint256 totalProofMinted;\n        uint256 totalProofRedeemed;\n    }\n\n    // ============ Storage Access ============\n\n    /**\n     * @notice Get the app storage struct\n     */\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 position = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    // ============ Role Modifiers ============\n\n    function enforceIsAdmin() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ADMIN_ROLE][msg.sender], \"LibAppStorage: Must be admin\");\n    }\n\n    function enforceIsOracle() internal view {\n        AppStorage storage s = appStorage();\n        require(s.roles[ORACLE_ROLE][msg.sender], \"LibAppStorage: Must be oracle\");\n    }\n\n    function enforceNotPaused() internal view {\n        require(!appStorage().paused, \"LibAppStorage: Contract is paused\");\n    }\n\n    function hasRole(bytes32 role, address account) internal view returns (bool) {\n        return appStorage().roles[role][account];\n    }\n\n    function grantRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = true;\n    }\n\n    function revokeRole(bytes32 role, address account) internal {\n        appStorage().roles[role][account] = false;\n    }\n}\n"
      }
    }
  }
}